{"name":"Crystal-Water","tagline":"OpenGL Concept Exploration - Ray Tracing and Particle Systems","body":"**Premise**: The current, shader-based GPU pipeline in OpenGL makes ray tracing\r\nin real time prohibitively complex and inflexible, resulting in an industry\r\navoidance of OpenGL for this kind of rendering.  By using OpenCL and its\r\nOpenGL interoperability to reconfigure this pipeline, we will achieve real-time\r\nray tracing with an OpenGL program on a modest desktop computer.  Further, we may\r\napproximate this functionality with greater ease and integration with the OpenGL\r\npipeline by exploring the new compute shaders now that parts of the OpenGL 4.3\r\nstandard are available.\r\n\r\nBy completion, this project will ideally render a crystal cube or sphere\r\nsuspended in a textured skybox and surrounded by or interacting with a\r\nparticle system-based water feature.\r\n\r\n**Working branch**: opencl\r\n\r\n___\r\n\r\n**Required libraries**: GLEW, Freeglut, GLM, SOIL, Assimp\r\n\r\n**Stage 1** (complete): Establish controls and render primitive object in a skybox.  \r\n - Challenge : *Which modern libraries are robust, supported, and commonly\r\n                        in use? How do we use the mouse wheel to zoom? How can we\r\n                        adapt arcball rotation for a more application-specific\r\n                        control system?*  \r\n - Solution : *GLM math library, SOIL image library, and AssImp model\r\n                        are ideal for this and future projects. Rotation is disc-\r\n                        based with a vertical slide. Zoom uses mousewheel in spite\r\n                        of Freeglut's fail in recognizing the mousewheel funcion.*  \r\n\r\n**Stage 2** (skipped) : Ray trace the cube to give it a crystal appearance using GLSL.  \r\n - Challenge : *Ray-plane intersections should be done on the GPU, but after\r\n                        calculating the destination vertex, how do we get the assoc.\r\n                        tex coord from the VBO?  Shaders do not provide access to a\r\n                        Vertex Buffer element from within another.*  \r\n - Solution : ~~Send a Uniform Buffer with vertex/texCoord pairings to the\r\n                        shaders for real-time lookup.  Unfortunately, this increases\r\n                        set-up time and is not scalable to larger systems or scenes.~~  \r\n - Problem : *While the Uniform Buffer solution is demonstrably possible\r\n                        for small systems, it is hacky, complicated, and extremely\r\n                        ugly.  And it will never port to anything greater.  Gave up\r\n                        on doing this with GLSL.*\r\n\r\n**Stage 3** (current) : Integrate OpenCL 1.2 to handle ray tracing in GPU kernels. [branched]  \r\n - Challenge : *How can we use the more ideal OpenCL API to solve our GLSL\r\n                        problems?  How can we accomplish this within the context of\r\n                        an OpenGL application?*  \r\n - Solution : *Unfortunately, this solution will be somewhat tedious.  OpenCL\r\n                        can release its shared-memory buffers to OpenGL, but there seems\r\n                        no way to integrate smoothly with the GLSL shading pipeline. We\r\n                        must perform all transformations and fragment calculations and\r\n                        render the output to a frame buffer to be copied over and swapped\r\n                        out after the fragment shader step.*\r\n\r\n**Stage 4** (planned) : Add some simulation of water to this project.  \r\n - Challenge : *Water can be mesh-based or particle-based. Let's learn the\r\n                        concept of particle systems and use that to simulate water\r\n                        in our ray-traced scene.*  \r\n\r\n**Stage 5** (planned) : Implement compute shaders to handle ray tracing in GPU kernels.  \r\n - Challenge : *OpenCL made parallel computation with global data possible\r\n                        where it otherwise had not been. Khronos has now introduced\r\n                        compute shaders using GLSL semantics to approximate the usage\r\n                        of OpenCL with greater integration in the OpenGL program. This\r\n                        is still brand new and must be explored.*\r\n\r\n___\r\n\r\nThis project is an exploration of modern OpenGL concepts including:\r\n  - GLSL 4.20\r\n  - OpenGL 4.20\r\n  - OpenCL 1.2\r\n  - Freeglut Extended features\r\n  - Modern libraries\r\n  - Vertex/Uniform/Index/Frame Buffers\r\n  - Lighting models\r\n  - Mesh loading\r\n  - Arcball-like control\r\n  - Using a skybox\r\n  - Texture loading, mapping, and sampling\r\n  - Ray tracing**\r\n  - Particle Systems**\r\n  - Compute Shaders**\r\n\r\n(**) denotes concepts yet to be implemented.\r\n\r\n___\r\n\r\nDesign Hardware: &nbsp; Athlon II X4 640, 8GB RAM, Sapphire Radeon HD 6870  \r\nDesign Software: &nbsp; Eclipse CDT Juno on Kubuntu 13.04 Raring\r\n\r\n___\r\n\r\n**Notes**:\r\n\r\nOpenCL 1.2 supports built-in gentypes, vector manipulations, and even printfs!\r\n This was unexpected.  \r\n\r\nCustom Program class\r\n  - Loads user-specified shader files as Shaderobj objects.\r\n  - Simplifies the most common calls in setup and execution.\r\n  - Makes multiple shader programs much simpler.\r\n\r\nCustom Quaternion class\r\n  - Need to avoid gimbal lock.\r\n  - Allows slerping (Spherical Linear intERPolation).\r\n  - Understood just enough to put it together and make it robust.\r\n\r\nCustom Mesh class\r\n  - Uses AssImp to import object/model files.\r\n  - Uses SOIL to load and bind the texture files read in from AssImp.\r\n  - Automatically prepares VBO/IBOs from the imported scene data.\r\n\r\nMatrix management\r\n  - Deprecation of matrix stack and GLSL built-in variables.\r\n  - All maintained by hand (with help from GLM and my quaternions).\r\n  - School has only taught direct/immediate mode thus far.","google":"UA-40092824-1","note":"Don't delete this file! It's used internally to help with page regeneration."}