<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Crystal-Water by nolnoch</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/nolnoch/crystal-water">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/nolnoch/crystal-water/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/nolnoch/crystal-water/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Crystal-Water</h1>
          <p>OpenGL Concept Exploration - Ray Tracing and Particle Systems</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/nolnoch">nolnoch</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>

        <p><strong>Premise</strong>: The current, shader-based GPU pipeline in OpenGL makes ray tracing
in real time prohibitively complex and inflexible, resulting in an industry
avoidance of OpenGL for this kind of rendering.  By using OpenCL and its
OpenGL interoperability to reconfigure this pipeline, we will achieve real-time
ray tracing with an OpenGL program on a modest desktop computer.  Further, we may
approximate this functionality with greater ease and integration with the OpenGL
pipeline by exploring the new compute shaders.</p>

<p>By completion, this project will ideally render a crystal cube or sphere
suspended in a textured skybox and surrounded by or interacting with a
particle system-based water feature.</p>

<p><strong>Working branch</strong>: opencl</p>

<hr><p><strong>Required libraries</strong>: GLEW, Freeglut, GLM, SOIL, Assimp</p>

<p><strong>Stage 1</strong> (complete): Establish controls and render primitive object in a skybox.  </p>

<ul>
<li>Challenge : <em>Which modern libraries are robust, supported, and commonly
                    in use? How do we use the mouse wheel to zoom? How can we
                    adapt arcball rotation for a more application-specific
                    control system?</em><br>
</li>
<li>Solution : <em>GLM math library, SOIL image library, and AssImp model
                    are ideal for this and future projects. Rotation is disc-
                    based with a vertical slide. Zoom uses mousewheel in spite
                    of Freeglut's fail in recognizing the mousewheel funcion.</em><br>
</li>
</ul><p><strong>Stage 2</strong> (skipped) : Ray trace the cube to give it a crystal appearance using GLSL.  </p>

<ul>
<li>Challenge : <em>Ray-plane intersections should be done on the GPU, but after
                    calculating the destination vertex, how do we get the assoc.
                    tex coord from the VBO?  Shaders do not provide access to a
                    Vertex Buffer element from within another.</em><br>
</li>
<li>Solution : <del>Send a Uniform Buffer with vertex/texCoord pairings to the
                    shaders for real-time lookup.  Unfortunately, this increases
                    set-up time and is not scalable to larger systems or scenes.</del><br>
</li>
<li>Problem : <em>While the Uniform Buffer solution is demonstrably possible
                    for small systems, it is hacky, complicated, and extremely
                    ugly.  And it will never port to anything greater.  Gave up
                    on doing this with GLSL.</em>
</li>
</ul><p><strong>Stage 3</strong> (current) : Integrate OpenCL 1.2 to handle ray tracing in GPU kernels. [branched]  </p>

<ul>
<li>Challenge : <em>How can we use the more ideal OpenCL API to solve our GLSL
                    problems?  How can we accomplish this within the context of
                    an OpenGL application?</em><br>
</li>
</ul><p><strong>Stage 4</strong> (planned) : Implement compute shaders to handle ray tracing in GPU kernels.  </p>

<ul>
<li>Challenge : <em>OpenCL made parallel computation with global data possible
                    where it otherwise had not been. Khronos has now introduced
                    compute shaders using GLSL semantics to approximate the usage
                    of OpenCL with greater integration in the OpenGL program. This
                    is still brand new and must be explored.</em><br>
</li>
</ul><p><strong>Stage 5</strong> (planned) : Add some simulation of water to this project.  </p>

<ul>
<li>Challenge : <em>Water can be mesh-based or particle-based. Let's learn the
                    concept of particle systems and use that to simulate water
                    in our ray-traced scene.</em><br>
</li>
</ul><hr><p>This project is an exploration of modern OpenGL concepts including:</p>

<ul>
<li>GLSL 4.20</li>
<li>OpenGL 4.20</li>
<li>OpenCL 1.2</li>
<li>Compute Shaders**</li>
<li>Freeglut Extended features</li>
<li>Modern libraries</li>
<li>Vertex/Uniform Buffers and Element Arrays</li>
<li>Lighting models</li>
<li>Mesh loading</li>
<li>Arcball-like control</li>
<li>Using a skybox</li>
<li>Texture loading, mapping, and sampling</li>
<li>Ray tracing**</li>
<li>Particle Systems**</li>
</ul><p>(**) denotes concepts yet to be implemented.</p>

<hr><p>Design Hardware:   Athlon II X4 640, 8GB RAM, Sapphire Radeon HD 6870<br>
Design Software:   Eclipse CDT Juno on Kubuntu 12.10 Quantal</p>

<hr><p><strong>Notes</strong>:</p>

<p>Custom Program class</p>

<ul>
<li>Loads user-specified shader files as Shaderobj objects.</li>
<li>Simplifies the most common calls in setup and execution.</li>
<li>Makes multiple shader programs much simpler.</li>
</ul><p>Custom Quaternion class</p>

<ul>
<li>Need to avoid gimbal lock.</li>
<li>Allows slerping (Spherical Linear intERPolation).</li>
<li>Understood just enough to put it together and make it robust.</li>
</ul><p>Custom Mesh class</p>

<ul>
<li>Uses AssImp to import object/model files.</li>
<li>Uses SOIL to load and bind the texture files read in from AssImp.</li>
<li>Automatically prepares VBO/IBOs from the imported scene data.</li>
</ul><p>Matrix management</p>

<ul>
<li>Deprecation of matrix stack and GLSL built-in variables.</li>
<li>All maintained by hand (with help from GLM and my quaternions).</li>
<li>School has only taught direct/immediate mode thus far.</li>
</ul>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-40092824-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>